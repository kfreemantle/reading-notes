# HTML lists, control flow with JS, CSS box model

### 1/25 Code review, lecture and reading notes

You need to do **much** better about time and attention management.  Shake off the rust my man!

----

We were shown a new way to do **concatenation.**  Instead of single quoting out, using + operators and having to deal with escape characters, you can use the **`** character, aka the PC game console key.  Any outside operators you need to reference, you enclose with **${curlymoney}** brackets.

> console.log(`It's $(userVariable) to save the day!`)

When using the .toLowerCase() and .toUpperCase() functions, you can just **append** them to the end of a prompt! Save some time.

> let userName = prompt('What's your name?').toLowerCase();   // the output is returned in lower case without extra lines of code.  Much more readable.

Getting into the lecture notes, we're going to start talking about more complex data types.  To start with, **arrays**.  Arrays are *containters* that hold values.  It's kind of like a list.  It's made up of a number of **elements,** each of which have a **index** in the array.  The *index* is a key identifier for the element in the list.  It counts up from **0**.  Put another way, **the index is place the element holds in the array.**

> let parksNRec = ['Leslie', 'April', 'Ron', 'Andy', 'Tom']

In this example, we have six elements, Leslie through Tom.  Even though there's *six elements,* the index value of Tom is *five,* because we count up from Leslie's *zero.*

Arrays can contain any data type, including other functions or even other arrays.  One of the most common combinations for arrays is **for loops**.  For loops run for *as long as the condition is true.*

#### Loops

Loops are functinos that run for as long as a condition is **true.**  Compare that with a if statement, which runs once.

 > if (condition) {
  // code that runs once, then moves on to the next line
 }
 > let i = 0     // the i stands for the 'iterator'
> i < parkNRec.length   // this part is used to evaluate the variable
> i = i+1   or   i++   // this is the increment to go up by.  i++ is a shorthand way to increment up by 1.

> for (let i =0; i < parkNRec.length; i++) {
  // this code will run as long as the condition for i evaluates to true.
}

let waffles = [`JJ's`, true, [228,343], `bacon`];
If you see brackets in JS, it's almost always an array.

Arrays can be updated with more values by declaring them by their index.
> parksNRec[6] = `Donna`;   // this added Donna at index 6 to the parksNRec array

Another method is to use the **push** function.

> parksNRec.push(`Tammy`, `Chris`, `Jerry`);  // this is a easier way, pushing however many more values you define in the arguments into the parksNRec array.  It adds them to the **end** of the array.

> parksNRec.unshift(`Tim`); // this slots the element into the front of the array and shifts the other indexes to adjust for it.

Moving on to CSS box model.

#### CSS Box Model

CSS is weird in how it calculates how content displays on the page.
 ![weird-css-sizing](csssizing.png)

Don't put up with that.  At the top of your css page implement **border-box-styling.**  At the top of your CSS sheet, add:

> * {
  box-sizing: border-box;   // this code makes the CSS imaging rules behave the way you'd expect, where the box is stated in full pixel width instead of doing a bunch of math.
}

Let's look at **div** and **span**.  With a few exceptions, almost all HTML tags default to either display **block** or display in **line**.  Div displays block, span displays line.

* Block elements take up the **entire width of their parent element.**  They will go as wide as they are allowed to go.  Block elements will knock any sibling elements down to the next line.
* Inline elements are **the width of their content,** and flow with the content arouind them.

***Inline elements are meant to flow with the content!!***

The default rule can be overrideen with every element in the CSS sheet by using the **display** characteristic.  One option for this attribute is **inline-block**.  [W3schools has a great summary of how inline-block works.](https://www.w3schools.com/css/css_inline-block.asp)  You can also use **float** to choose to orient the content to either side of the screen, but this can be finnicky.  Float is VERY good for wrapping text around photos.

With the CSS sheet we can also declare **classes** and **IDs** to apply our styling more selectively.
The class attribute can be included in the opening tag of whatever element.

> .class{
  width: 80%;
  background-color: gray;
  margin-left: auto;
  margin-rigt: auto; // you want to use BOTh auto options, because otherwise it'll just smoosh up against one side of the page.
}

#### CSS psuedo selectors

You'll use a lot of these in the CSS Diner assignment for lab 5.  A **CSS psuedo selector** is a selector that targets its elements relative to its **parent** element.  

> div:first-of type {
  // styling to affect any of the first div child element of any parent
}

A **while** loop will run continually as long as the condition resolves to true.  This can be used in conjunction with a incremental counter to count or limit user attempts.  Remember, **a zero resolves to false!**

> let attemptsRemaining = 4;
> while (attemptsRemaining) {
> attemptsRemaining--;  // this decrements the attemptsRemaining by 1 every time the code runs, which it should as long as attemptsRemaining is more than zero.
> // code that runs as long as attemptsRemaining resolves to true.
> console.log(`The user has ${attemptsRemaining} attempts remaining.`)
>}

Another example of a for loop to count down questino attempts:

>let attempts = 7;
>
>for (let i=0; i < attempts; i++) {
> console.log(`The user has ${attempts} attempts remaining.`);
>}

One more example using an array from the lecture.

 let myFavColors = [`blue`, `red`, `black`];
 let userResponse = 'orange';
 let attemptsRemaining = 3;
 while (attemptsRemaining) {
 attemptsRemaining--;
 console.log(`I'm in the while loop. You have ${attemptsRemaining}`);
 for (let i =0; i < myFavColors.length; i++) {
   console.log(myFavColors[i]);  
   if (myFavColors[i] === userResponse) {
    console.log('You are correct!')
    }
  }
 }

let attemptsRemaining = 5
let userAnswerCorrect = false;

for (let i =0; i< attemptsRemaining; i++) {
  console.log(`The user has ${attemptsRemaining - i - 1} attempts remaining.`);
    for (let j = 0; j < myFavColors.length; j++) {
      if (myFavColors[j] === userResponse) {
        console.log(`You are correct!`);
      }
    }
})

##### Things I want to know more about

* Common pairings for nested functions, like arrays and for loops.
* Best practices for whiteboarding logical statements before committing ANYTHING to code.
